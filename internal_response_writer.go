package newrelic

import (
	"bufio"
	"io"
	"net"
	"net/http"
)

func (trd *thread) CloseNotify() <-chan bool {
	return trd.txn.getWriter().(http.CloseNotifier).CloseNotify()
}
func (trd *thread) Flush() {
	trd.txn.getWriter().(http.Flusher).Flush()
}
func (trd *thread) Hijack() (net.Conn, *bufio.ReadWriter, error) {
	return trd.txn.getWriter().(http.Hijacker).Hijack()
}
func (trd *thread) ReadFrom(r io.Reader) (int64, error) {
	return trd.txn.getWriter().(io.ReaderFrom).ReadFrom(r)
}

func upgradeTxn(trd *thread) Transaction {
	// Note that trd.txn.getWriter() is not used here.  The transaction is
	// locked (or under construction) when this function is used.

	// GENERATED CODE DO NOT MODIFY
	// This code generated by internal/tools/interface-wrapping
	var (
		i0 int32 = 1 << 0
		i1 int32 = 1 << 1
		i2 int32 = 1 << 2
		i3 int32 = 1 << 3
	)
	var interfaceSet int32
	if _, ok := trd.txn.writer.(http.CloseNotifier); ok {
		interfaceSet |= i0
	}
	if _, ok := trd.txn.writer.(http.Flusher); ok {
		interfaceSet |= i1
	}
	if _, ok := trd.txn.writer.(http.Hijacker); ok {
		interfaceSet |= i2
	}
	if _, ok := trd.txn.writer.(io.ReaderFrom); ok {
		interfaceSet |= i3
	}
	switch interfaceSet {
	default: // No optional interfaces implemented
		return struct {
			Transaction
		}{trd}
	case i0:
		return struct {
			Transaction
			http.CloseNotifier
		}{trd, trd}
	case i1:
		return struct {
			Transaction
			http.Flusher
		}{trd, trd}
	case i0 | i1:
		return struct {
			Transaction
			http.CloseNotifier
			http.Flusher
		}{trd, trd, trd}
	case i2:
		return struct {
			Transaction
			http.Hijacker
		}{trd, trd}
	case i0 | i2:
		return struct {
			Transaction
			http.CloseNotifier
			http.Hijacker
		}{trd, trd, trd}
	case i1 | i2:
		return struct {
			Transaction
			http.Flusher
			http.Hijacker
		}{trd, trd, trd}
	case i0 | i1 | i2:
		return struct {
			Transaction
			http.CloseNotifier
			http.Flusher
			http.Hijacker
		}{trd, trd, trd, trd}
	case i3:
		return struct {
			Transaction
			io.ReaderFrom
		}{trd, trd}
	case i0 | i3:
		return struct {
			Transaction
			http.CloseNotifier
			io.ReaderFrom
		}{trd, trd, trd}
	case i1 | i3:
		return struct {
			Transaction
			http.Flusher
			io.ReaderFrom
		}{trd, trd, trd}
	case i0 | i1 | i3:
		return struct {
			Transaction
			http.CloseNotifier
			http.Flusher
			io.ReaderFrom
		}{trd, trd, trd, trd}
	case i2 | i3:
		return struct {
			Transaction
			http.Hijacker
			io.ReaderFrom
		}{trd, trd, trd}
	case i0 | i2 | i3:
		return struct {
			Transaction
			http.CloseNotifier
			http.Hijacker
			io.ReaderFrom
		}{trd, trd, trd, trd}
	case i1 | i2 | i3:
		return struct {
			Transaction
			http.Flusher
			http.Hijacker
			io.ReaderFrom
		}{trd, trd, trd, trd}
	case i0 | i1 | i2 | i3:
		return struct {
			Transaction
			http.CloseNotifier
			http.Flusher
			http.Hijacker
			io.ReaderFrom
		}{trd, trd, trd, trd, trd}
	}
}
